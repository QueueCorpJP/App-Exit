
-- =========================================================================
-- Supabase / PostgreSQL Schema for M&A Board Platform
-- Includes: Types, Tables, Partitioning, Indexes, RLS Policies, Functions, RPC
-- =========================================================================

-- ------------------------------
-- EXTENSIONS (if not already enabled)
-- ------------------------------
create extension if not exists "pgcrypto";
create extension if not exists "uuid-ossp";

-- ------------------------------
-- TYPES
-- ------------------------------
do $$ begin
  if not exists (select 1 from pg_type where typname = 'role_type') then
    create type role_type as enum ('buyer','seller');
  end if;
  if not exists (select 1 from pg_type where typname = 'party_type') then
    create type party_type as enum ('individual','organization');
  end if;
  if not exists (select 1 from pg_type where typname = 'post_type') then
    create type post_type as enum ('board','transaction','secret');
  end if;
  if not exists (select 1 from pg_type where typname = 'nda_status') then
    create type nda_status as enum ('none','requested','signed','rejected');
  end if;
  if not exists (select 1 from pg_type where typname = 'contract_check_status') then
    create type contract_check_status as enum ('pending','checked');
  end if;
  if not exists (select 1 from pg_type where typname = 'message_type') then
    create type message_type as enum ('text','image','contract_item');
  end if;
  if not exists (select 1 from pg_type where typname = 'payment_status') then
    create type payment_status as enum ('none','requires_action','processing','succeeded','canceled','refunded');
  end if;
  if not exists (select 1 from pg_type where typname = 'secret_visibility') then
    create type secret_visibility as enum ('full','price_only','hidden');
  end if;
end $$;

-- ------------------------------
-- HELPER FUNCTIONS
-- ------------------------------
-- is_admin: checks JWT claim `role = admin`
create or replace function public.is_admin()
returns boolean
language sql stable security definer set search_path = public
as $$
  select coalesce( (auth.jwt() ->> 'role') = 'admin', false );
$$;

-- is_member_of_org: whether auth.uid() belongs to a given org
create or replace function public.is_member_of_org(p_org_id uuid)
returns boolean
language sql stable security definer set search_path = public
as $$
  select exists (
    select 1
    from public.org_memberships m
    where m.org_id = p_org_id
      and m.user_id = auth.uid()
  ) or exists (
    select 1
    from public.organizations o
    where o.id = p_org_id
      and o.owner_user_id = auth.uid()
  );
$$;

-- ------------------------------
-- ACCOUNTS / ORGS / PROFILES
-- ------------------------------
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  role role_type not null,
  party party_type not null,
  display_name text not null,
  age int check (age between 13 and 120),
  icon_url text,
  nda_flag boolean default false,
  terms_accepted_at timestamptz,
  privacy_accepted_at timestamptz,
  stripe_customer_id text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.organizations (
  id uuid primary key default gen_random_uuid(),
  owner_user_id uuid not null references auth.users(id) on delete restrict,
  legal_name text not null,
  nda_status nda_status not null default 'none',
  stripe_account_id text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.org_memberships (
  org_id uuid not null references public.organizations(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role_in_org text default 'member',
  created_at timestamptz not null default now(),
  primary key (org_id, user_id)
);

-- updated_at triggers
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end $$;

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at before update on public.profiles
for each row execute function public.set_updated_at();

drop trigger if exists trg_orgs_updated_at on public.organizations;
create trigger trg_orgs_updated_at before update on public.organizations
for each row execute function public.set_updated_at();

-- ------------------------------
-- NDA
-- ------------------------------
create table if not exists public.nda_agreements (
  id uuid primary key default gen_random_uuid(),
  buyer_org_id uuid references public.organizations(id),
  buyer_user_id uuid references auth.users(id),
  seller_org_id uuid references public.organizations(id),
  seller_user_id uuid references auth.users(id),
  status nda_status not null default 'requested',
  signed_at timestamptz,
  doc_url text,
  created_at timestamptz not null default now(),
  constraint unique_pair unique (coalesce(buyer_org_id::text, buyer_user_id::text), coalesce(seller_org_id::text, seller_user_id::text))
);

-- helper: whether current viewer has NDA signed with the seller side of a post
create or replace function public.has_signed_nda_with_post_seller(p_post_id uuid)
returns boolean
language sql stable security definer set search_path = public
as $$
  with p as (
    select author_user_id, author_org_id
    from public.posts
    where id = p_post_id
  ), viewer as (
    select auth.uid() as vid
  ), viewer_orgs as (
    -- orgs the viewer belongs to (including one they own)
    select o.id as org_id
    from public.organizations o
    left join public.org_memberships m on m.org_id = o.id
    where o.owner_user_id = (select vid from viewer)
       or m.user_id = (select vid from viewer)
  )
  select exists (
    select 1
    from public.nda_agreements a, p
    where a.status = 'signed'
      and (
        (a.seller_org_id is not null and a.seller_org_id = p.author_org_id) or
        (a.seller_user_id is not null and a.seller_user_id = p.author_user_id)
      )
      and (
        -- viewer as org
        (a.buyer_org_id in (select org_id from viewer_orgs))
        or
        -- viewer as individual
        (a.buyer_user_id = (select vid from viewer))
      )
  );
$$;

-- ------------------------------
-- POSTS (PARTITIONED by LIST on type)
-- ------------------------------
create table if not exists public.posts (
  id uuid not null,
  author_user_id uuid not null references auth.users(id) on delete restrict,
  author_org_id uuid references public.organizations(id),
  type post_type not null,
  title text not null,
  body text,
  cover_image_url text,
  budget_min bigint,
  budget_max bigint,
  price bigint,
  secret_visibility secret_visibility default 'full',
  is_active boolean default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  check ( (type <> 'transaction' or price is not null) ),
  primary key (id)
) partition by list (type);

-- partitions
create table if not exists public.posts_board partition of public.posts
  for values in ('board');
create table if not exists public.posts_transaction partition of public.posts
  for values in ('transaction');
create table if not exists public.posts_secret partition of public.posts
  for values in ('secret');

-- indexes (partitioned indexes will create on children)
create index if not exists idx_posts_active_created on public.posts (is_active, created_at desc);
create index if not exists idx_posts_author on public.posts (author_user_id);
create index if not exists idx_posts_type_created on public.posts (type, created_at desc);

-- trigger for updated_at
drop trigger if exists trg_posts_updated_at on public.posts;
create trigger trg_posts_updated_at before update on public.posts
for each row execute function public.set_updated_at();

-- details (not partitioned)
create table if not exists public.post_details (
  post_id uuid primary key references public.posts(id) on delete cascade,
  app_name text,
  app_category text,
  monthly_revenue bigint,
  monthly_profit bigint,
  mau bigint,
  dau bigint,
  store_url text,
  tech_stack text,
  notes text
);

-- ------------------------------
-- VISIBILITY RPC: returns redacted rows according to NDA for 'secret'
-- ------------------------------
-- Return a redacted projection to avoid exposing sensitive fields without NDA
create or replace function public.get_posts_for_viewer()
returns table (
  id uuid,
  author_user_id uuid,
  author_org_id uuid,
  type post_type,
  title text,
  body text,
  cover_image_url text,
  budget_min bigint,
  budget_max bigint,
  price bigint,
  is_secret boolean,
  visible_mode secret_visibility,
  is_active boolean,
  created_at timestamptz
)
language sql stable security definer set search_path = public
as $$
  with base as (
    select p.*,
           (p.type = 'secret') as is_secret,
           case
             when p.type <> 'secret' then 'full'::secret_visibility
             when public.has_signed_nda_with_post_seller(p.id) then 'full'::secret_visibility
             else 'price_only'::secret_visibility
           end as visible_mode
    from public.posts p
    where p.is_active = true
  )
  select
    b.id,
    b.author_user_id,
    b.author_org_id,
    b.type,
    case when b.is_secret and b.visible_mode <> 'full' then null else b.title end as title,
    case when b.is_secret and b.visible_mode <> 'full' then null else b.body end as body,
    case when b.is_secret and b.visible_mode <> 'full' then null else b.cover_image_url end as cover_image_url,
    case when b.type = 'board' then b.budget_min else b.budget_min end as budget_min,
    case when b.type = 'board' then b.budget_max else b.budget_max end as budget_max,
    b.price,
    b.is_secret,
    b.visible_mode,
    b.is_active,
    b.created_at
  from base b
  -- hide secret entirely from unrelated viewers if you want:
  -- where not (b.is_secret and b.visible_mode = 'hidden')
  order by b.created_at desc;
$$;

-- helper to check full-visibility on a given post (used for details)
create or replace function public.can_view_post_full(p_post_id uuid)
returns boolean
language sql stable security definer set search_path = public
as $$
  select case
    when (select type from public.posts where id = p_post_id) <> 'secret' then true
    when (select author_user_id from public.posts where id = p_post_id) = auth.uid() then true
    else public.has_signed_nda_with_post_seller(p_post_id)
  end;
$$;

-- ------------------------------
-- DM / THREADS / MESSAGES (RANGE PARTITIONED by created_at monthly)
-- ------------------------------
create table if not exists public.threads (
  id uuid primary key default gen_random_uuid(),
  created_by uuid not null references auth.users(id),
  related_post_id uuid references public.posts(id),
  created_at timestamptz not null default now()
);

create table if not exists public.thread_participants (
  thread_id uuid not null references public.threads(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  primary key (thread_id, user_id)
);

-- messages parent
create table if not exists public.messages (
  id uuid not null,
  thread_id uuid not null references public.threads(id) on delete cascade,
  sender_user_id uuid not null references auth.users(id),
  type message_type not null default 'text',
  text text,
  created_at timestamptz not null default now(),
  primary key (id, created_at)
) partition by range (created_at);

-- helper to make monthly partitions (example 2025-01 .. 2026-01)
do $$
declare
  y int := 2025;
  m int := 1;
  stop_y int := 2026;
  stop_m int := 12;
  part_name text;
  start_ts timestamptz;
  end_ts timestamptz;
begin
  while (y < stop_y) or (y = stop_y and m <= stop_m) loop
    part_name := format('messages_%s_%s', y, lpad(m::text,2,'0'));
    start_ts := to_timestamp(format('%s-%s-01 00:00:00', y, lpad(m::text,2,'0')), 'YYYY-MM-DD HH24:MI:SS');
    if m = 12 then
      end_ts := to_timestamp(format('%s-01-01 00:00:00', y+1), 'YYYY-MM-DD HH24:MI:SS');
    else
      end_ts := to_timestamp(format('%s-%s-01 00:00:00', y, lpad((m+1)::text,2,'0')), 'YYYY-MM-DD HH24:MI:SS');
    end if;
    execute format('create table if not exists public.%I partition of public.messages for values from (%L) to (%L);', part_name, start_ts, end_ts);
    m := m + 1;
    if m = 13 then
      m := 1;
      y := y + 1;
    end if;
  end loop;
end $$;

create index if not exists idx_messages_thread_created on public.messages (thread_id, created_at);
create index if not exists idx_messages_sender_created on public.messages (sender_user_id, created_at);

-- prevent UPDATE/DELETE (immutability)
create or replace rule messages_no_update as on update to public.messages do instead nothing;
create or replace rule messages_no_delete as on delete to public.messages do instead nothing;

create table if not exists public.message_attachments (
  id uuid primary key default gen_random_uuid(),
  message_id uuid not null references public.messages(id) on delete cascade,
  file_url text not null,
  created_at timestamptz not null default now()
);

create table if not exists public.contract_items (
  id uuid primary key default gen_random_uuid(),
  thread_id uuid not null references public.threads(id) on delete cascade,
  label text not null,
  required boolean default true,
  created_at timestamptz not null default now()
);

create table if not exists public.contract_checks (
  item_id uuid not null references public.contract_items(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  status contract_check_status not null default 'pending',
  checked_at timestamptz,
  primary key (item_id, user_id)
);

-- ------------------------------
-- ORDERS / PAYMENTS
-- ------------------------------
create table if not exists public.orders (
  id uuid primary key default gen_random_uuid(),
  buyer_user_id uuid not null references auth.users(id),
  buyer_org_id uuid references public.organizations(id),
  seller_user_id uuid references auth.users(id),
  seller_org_id uuid references public.organizations(id),
  post_id uuid not null references public.posts(id),
  amount bigint not null,
  currency text not null default 'jpy',
  payment_status payment_status not null default 'none',
  all_contract_items_checked boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint chk_buyer_present check (buyer_user_id is not null),
  constraint chk_seller_present check (seller_user_id is not null or seller_org_id is not null)
);

drop trigger if exists trg_orders_updated_at on public.orders;
create trigger trg_orders_updated_at before update on public.orders
for each row execute function public.set_updated_at();

create table if not exists public.stripe_payments (
  id uuid primary key default gen_random_uuid(),
  order_id uuid not null references public.orders(id) on delete cascade,
  payment_intent_id text not null,
  client_secret text,
  status payment_status not null default 'processing',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists trg_stripe_payments_updated_at on public.stripe_payments;
create trigger trg_stripe_payments_updated_at before update on public.stripe_payments
for each row execute function public.set_updated_at();

-- ------------------------------
-- AUDIT LOGS (RANGE PARTITIONED monthly)
-- ------------------------------
create table if not exists public.audit_logs (
  id bigserial,
  table_name text not null,
  row_id uuid,
  action text not null,
  actor_user_id uuid,
  occurred_at timestamptz not null default now(),
  diff jsonb,
  primary key (id, occurred_at)
) partition by range (occurred_at);

do $$
declare
  y int := 2025;
  m int := 1;
  stop_y int := 2026;
  stop_m int := 12;
  part_name text;
  start_ts timestamptz;
  end_ts timestamptz;
begin
  while (y < stop_y) or (y = stop_y and m <= stop_m) loop
    part_name := format('audit_logs_%s_%s', y, lpad(m::text,2,'0'));
    start_ts := to_timestamp(format('%s-%s-01 00:00:00', y, lpad(m::text,2,'0')), 'YYYY-MM-DD HH24:MI:SS');
    if m = 12 then
      end_ts := to_timestamp(format('%s-01-01 00:00:00', y+1), 'YYYY-MM-DD HH24:MI:SS');
    else
      end_ts := to_timestamp(format('%s-%s-01 00:00:00', y, lpad((m+1)::text,2,'0')), 'YYYY-MM-DD HH24:MI:SS');
    end if;
    execute format('create table if not exists public.%I partition of public.audit_logs for values from (%L) to (%L);', part_name, start_ts, end_ts);
    m := m + 1;
    if m = 13 then
      m := 1;
      y := y + 1;
    end if;
  end loop;
end $$;

create index if not exists idx_audit_logs_table_time on public.audit_logs (table_name, occurred_at desc);

-- ------------------------------
-- CONTRACT CHECK AGGREGATION RPC
-- ------------------------------
create or replace function public.refresh_order_contract_check(p_order_id uuid)
returns void
language plpgsql security definer set search_path = public
as $$
declare
  v_thread uuid;
  v_required_cnt int;
  v_checked_cnt int;
begin
  select t.id into v_thread
  from public.orders o
  join public.threads t on t.related_post_id = o.post_id
  where o.id = p_order_id
  order by t.created_at asc
  limit 1;

  if v_thread is null then
    update public.orders set all_contract_items_checked = false where id = p_order_id;
    return;
  end if;

  select count(*) into v_required_cnt from public.contract_items ci where ci.thread_id = v_thread and ci.required = true;
  select count(*) into v_checked_cnt
  from public.contract_checks cc
  join public.contract_items ci on ci.id = cc.item_id
  where ci.thread_id = v_thread and ci.required = true and cc.status = 'checked';

  update public.orders
  set all_contract_items_checked = (v_required_cnt > 0 and v_required_cnt = v_checked_cnt)
  where id = p_order_id;
end $$;

-- ------------------------------
-- RLS: ENABLE
-- ------------------------------
alter table public.profiles enable row level security;
alter table public.organizations enable row level security;
alter table public.org_memberships enable row level security;
alter table public.nda_agreements enable row level security;
alter table public.posts enable row level security;
alter table public.post_details enable row level security;
alter table public.threads enable row level security;
alter table public.thread_participants enable row level security;
alter table public.messages enable row level security;
alter table public.message_attachments enable row level security;
alter table public.contract_items enable row level security;
alter table public.contract_checks enable row level security;
alter table public.orders enable row level security;
alter table public.stripe_payments enable row level security;
alter table public.audit_logs enable row level security;

-- ------------------------------
-- RLS POLICIES
-- ------------------------------

-- profiles: owner can select/update; insert handled by backend
drop policy if exists "profiles_owner_select" on public.profiles;
create policy "profiles_owner_select" on public.profiles
for select using ( id = auth.uid() or public.is_admin() );

drop policy if exists "profiles_owner_update" on public.profiles;
create policy "profiles_owner_update" on public.profiles
for update using ( id = auth.uid() or public.is_admin() );

-- organizations: owner & members can select; owner update; owner insert
drop policy if exists "orgs_select_members" on public.organizations;
create policy "orgs_select_members" on public.organizations
for select using ( owner_user_id = auth.uid() or public.is_member_of_org(id) or public.is_admin() );

drop policy if exists "orgs_insert_owner" on public.organizations;
create policy "orgs_insert_owner" on public.organizations
for insert with check ( owner_user_id = auth.uid() or public.is_admin() );

drop policy if exists "orgs_update_owner" on public.organizations;
create policy "orgs_update_owner" on public.organizations
for update using ( owner_user_id = auth.uid() or public.is_admin() );

-- org_memberships: member or org owner
drop policy if exists "org_memberships_select" on public.org_memberships;
create policy "org_memberships_select" on public.org_memberships
for select using (
  user_id = auth.uid() or public.is_member_of_org(org_id) or public.is_admin()
);

drop policy if exists "org_memberships_insert_owner" on public.org_memberships;
create policy "org_memberships_insert_owner" on public.org_memberships
for insert with check ( public.is_member_of_org(org_id) or public.is_admin() );

drop policy if exists "org_memberships_delete_owner" on public.org_memberships;
create policy "org_memberships_delete_owner" on public.org_memberships
for delete using ( public.is_member_of_org(org_id) or public.is_admin() );

-- nda_agreements: only participants can see; insert by either side; update limited
drop policy if exists "nda_select_participants" on public.nda_agreements;
create policy "nda_select_participants" on public.nda_agreements
for select using (
  buyer_user_id = auth.uid()
  or seller_user_id = auth.uid()
  or public.is_member_of_org(coalesce(buyer_org_id, '00000000-0000-0000-0000-000000000000'::uuid))
  or public.is_member_of_org(coalesce(seller_org_id, '00000000-0000-0000-0000-000000000000'::uuid))
  or public.is_admin()
);

drop policy if exists "nda_insert_parties" on public.nda_agreements;
create policy "nda_insert_parties" on public.nda_agreements
for insert with check (
  auth.uid() is not null
);

drop policy if exists "nda_update_parties" on public.nda_agreements;
create policy "nda_update_parties" on public.nda_agreements
for update using (
  buyer_user_id = auth.uid()
  or seller_user_id = auth.uid()
  or public.is_member_of_org(coalesce(buyer_org_id, '00000000-0000-0000-0000-000000000000'::uuid))
  or public.is_member_of_org(coalesce(seller_org_id, '00000000-0000-0000-0000-000000000000'::uuid))
  or public.is_admin()
);

-- posts: author can manage; base-table select only for non-secret or author
drop policy if exists "posts_select_base" on public.posts;
create policy "posts_select_base" on public.posts
for select using (
  (type <> 'secret' and is_active = true)
  or author_user_id = auth.uid()
  or public.is_admin()
);

drop policy if exists "posts_insert_author" on public.posts;
create policy "posts_insert_author" on public.posts
for insert with check ( author_user_id = auth.uid() or public.is_admin() );

drop policy if exists "posts_update_author" on public.posts;
create policy "posts_update_author" on public.posts
for update using ( author_user_id = auth.uid() or public.is_admin() );

drop policy if exists "posts_delete_author" on public.posts;
create policy "posts_delete_author" on public.posts
for delete using ( author_user_id = auth.uid() or public.is_admin() );

-- post_details: viewable only if can_view_post_full
drop policy if exists "post_details_view" on public.post_details;
create policy "post_details_view" on public.post_details
for select using ( public.can_view_post_full(post_id) or public.is_admin() );

drop policy if exists "post_details_author_manage" on public.post_details;
create policy "post_details_author_manage" on public.post_details
for all using (
  exists (select 1 from public.posts p where p.id = post_id and p.author_user_id = auth.uid())
  or public.is_admin()
) with check (
  exists (select 1 from public.posts p where p.id = post_id and p.author_user_id = auth.uid())
  or public.is_admin()
);

-- threads: participants only
drop policy if exists "threads_select_participants" on public.threads;
create policy "threads_select_participants" on public.threads
for select using (
  exists (select 1 from public.thread_participants tp where tp.thread_id = id and tp.user_id = auth.uid())
  or public.is_admin()
);

drop policy if exists "threads_insert_creator" on public.threads;
create policy "threads_insert_creator" on public.threads
for insert with check ( created_by = auth.uid() or public.is_admin() );

-- thread_participants: a participant or thread creator can manage
drop policy if exists "thread_participants_select" on public.thread_participants;
create policy "thread_participants_select" on public.thread_participants
for select using (
  user_id = auth.uid()
  or exists (select 1 from public.threads t where t.id = thread_id and t.created_by = auth.uid())
  or public.is_admin()
);

drop policy if exists "thread_participants_manage" on public.thread_participants;
create policy "thread_participants_manage" on public.thread_participants
for all using (
  exists (select 1 from public.threads t where t.id = thread_id and t.created_by = auth.uid())
  or public.is_admin()
) with check (
  exists (select 1 from public.threads t where t.id = thread_id and t.created_by = auth.uid())
  or public.is_admin()
);

-- messages: participants only; updates/deletes blocked by RULEs
drop policy if exists "messages_select_participants" on public.messages;
create policy "messages_select_participants" on public.messages
for select using (
  exists (select 1 from public.thread_participants tp where tp.thread_id = thread_id and tp.user_id = auth.uid())
  or public.is_admin()
);

drop policy if exists "messages_insert_participants" on public.messages;
create policy "messages_insert_participants" on public.messages
for insert with check (
  exists (select 1 from public.thread_participants tp where tp.thread_id = thread_id and tp.user_id = auth.uid())
  or public.is_admin()
);

-- message_attachments: same visibility as message via join
drop policy if exists "msg_attachments_select" on public.message_attachments;
create policy "msg_attachments_select" on public.message_attachments
for select using (
  exists (
    select 1
    from public.messages m
    join public.thread_participants tp on tp.thread_id = m.thread_id
    where m.id = message_id and tp.user_id = auth.uid()
  ) or public.is_admin()
);

drop policy if exists "msg_attachments_insert" on public.message_attachments;
create policy "msg_attachments_insert" on public.message_attachments
for insert with check (
  exists (
    select 1
    from public.messages m
    join public.thread_participants tp on tp.thread_id = m.thread_id
    where m.id = message_id and tp.user_id = auth.uid()
  ) or public.is_admin()
);

-- contract_items/checks: thread participants only; checks updatable by same user
drop policy if exists "contract_items_select" on public.contract_items;
create policy "contract_items_select" on public.contract_items
for select using (
  exists (select 1 from public.thread_participants tp where tp.thread_id = thread_id and tp.user_id = auth.uid())
  or public.is_admin()
);

drop policy if exists "contract_items_manage" on public.contract_items;
create policy "contract_items_manage" on public.contract_items
for all using (
  exists (select 1 from public.thread_participants tp where tp.thread_id = thread_id and tp.user_id = auth.uid())
  or public.is_admin()
) with check (
  exists (select 1 from public.thread_participants tp where tp.thread_id = thread_id and tp.user_id = auth.uid())
  or public.is_admin()
);

drop policy if exists "contract_checks_select" on public.contract_checks;
create policy "contract_checks_select" on public.contract_checks
for select using (
  user_id = auth.uid()
  or exists (
    select 1 from public.contract_items ci
    join public.thread_participants tp on tp.thread_id = ci.thread_id
    where ci.id = item_id and tp.user_id = auth.uid()
  ) or public.is_admin()
);

drop policy if exists "contract_checks_upsert_self" on public.contract_checks;
create policy "contract_checks_upsert_self" on public.contract_checks
for all using ( user_id = auth.uid() or public.is_admin() )
with check ( user_id = auth.uid() or public.is_admin() );

-- orders: only parties or admin
drop policy if exists "orders_select_parties" on public.orders;
create policy "orders_select_parties" on public.orders
for select using (
  buyer_user_id = auth.uid()
  or exists (select 1 from public.organizations o where o.id = buyer_org_id and public.is_member_of_org(o.id))
  or seller_user_id = auth.uid()
  or exists (select 1 from public.organizations o2 where o2.id = seller_org_id and public.is_member_of_org(o2.id))
  or public.is_admin()
);

drop policy if exists "orders_insert_buyer" on public.orders;
create policy "orders_insert_buyer" on public.orders
for insert with check (
  buyer_user_id = auth.uid()
  or exists (select 1 from public.organizations o where o.id = buyer_org_id and public.is_member_of_org(o.id))
  or public.is_admin()
);

drop policy if exists "orders_update_parties" on public.orders;
create policy "orders_update_parties" on public.orders
for update using (
  buyer_user_id = auth.uid()
  or exists (select 1 from public.organizations o where o.id = buyer_org_id and public.is_member_of_org(o.id))
  or seller_user_id = auth.uid()
  or exists (select 1 from public.organizations o2 where o2.id = seller_org_id and public.is_member_of_org(o2.id))
  or public.is_admin()
);

-- stripe_payments follows orders
drop policy if exists "stripe_payments_select_parties" on public.stripe_payments;
create policy "stripe_payments_select_parties" on public.stripe_payments
for select using (
  exists (select 1 from public.orders o where o.id = order_id and (
    o.buyer_user_id = auth.uid()
    or exists (select 1 from public.organizations ob where ob.id = o.buyer_org_id and public.is_member_of_org(ob.id))
    or o.seller_user_id = auth.uid()
    or exists (select 1 from public.organizations os where os.id = o.seller_org_id and public.is_member_of_org(os.id))
    or public.is_admin()
  ))
);

drop policy if exists "stripe_payments_insert_buyer" on public.stripe_payments;
create policy "stripe_payments_insert_buyer" on public.stripe_payments
for insert with check (
  exists (select 1 from public.orders o where o.id = order_id and (
    o.buyer_user_id = auth.uid()
    or exists (select 1 from public.organizations ob where ob.id = o.buyer_org_id and public.is_member_of_org(ob.id))
    or public.is_admin()
  ))
);

-- audit_logs: read-only for admin; inserts via triggers (not included here)
drop policy if exists "audit_logs_admin_select" on public.audit_logs;
create policy "audit_logs_admin_select" on public.audit_logs
for select using ( public.is_admin() );

-- ------------------------------
-- OPTIONAL: example trigger to write audit logs on INSERT/UPDATE/DELETE
-- (implement per-table as needed)
-- ------------------------------
-- create or replace function public.audit_trigger()
-- returns trigger language plpgsql security definer as $$
-- begin
--   insert into public.audit_logs(table_name, row_id, action, actor_user_id, diff)
--   values (tg_table_name::text, coalesce((to_jsonb(new)->>'id')::uuid, (to_jsonb(old)->>'id')::uuid), tg_op, auth.uid(), case when tg_op='DELETE' then to_jsonb(old) else to_jsonb(new) end);
--   return case when tg_op='DELETE' then old else new end;
-- end $$;

-- attach per table:
-- create trigger trg_posts_audit after insert or update or delete on public.posts
-- for each row execute function public.audit_trigger();

-- =========================================================================
-- END OF SCHEMA
-- =========================================================================
