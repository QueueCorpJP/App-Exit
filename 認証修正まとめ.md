# 認証システム根本修正まとめ

## 問題の根本原因

### 1. バックエンドとフロントエンドの認証方式の不一致
- **バックエンド**: HttpOnly Cookieのみを読み取っていた
- **フロントエンド**: Authorizationヘッダーでトークンを送信していた
- **結果**: 保護されたエンドポイントへのAPIコールが全て401エラーで失敗

### 2. トークン保存場所の分散と同期不足
- LocalStorage (Supabaseセッション)
- React Context (メモリ上の状態)
- HttpOnly Cookie (バックエンドが設定)

これらが同期されておらず、ログイン状態の判定とAPI認証が不一致を起こしていた。

### 3. 危険な手動Cookie解析
`UserTypeSelectionPage.tsx`でHttpOnly Cookieを`document.cookie`から読み取ろうとしていた（HttpOnly Cookieは読み取れないため無効）。

---

## 実施した修正

### バックエンド修正

#### 1. `backend/internal/middleware/auth.go` - 認証ミドルウェア強化

**変更内容**:
```go
// 修正前: Cookieのみをチェック
cookie, err := r.Cookie("auth_token")
if err != nil || cookie.Value == "" {
    // エラー
}

// 修正後: Authorizationヘッダーを優先、なければCookieをフォールバック
var tokenString string
var tokenSource string

// 1. まずAuthorizationヘッダーから取得
authHeader := r.Header.Get("Authorization")
if authHeader != "" && len(authHeader) > 7 && authHeader[:7] == "Bearer " {
    tokenString = authHeader[7:]
    tokenSource = "Authorization header"
} else {
    // 2. なければCookieから取得
    cookie, err := r.Cookie("auth_token")
    if err != nil || cookie.Value == "" {
        // エラー
    }
    tokenString = cookie.Value
    tokenSource = "HttpOnly cookie"
}
```

**効果**:
- AuthorizationヘッダーとCookieの両方をサポート
- フロントエンドからの様々な認証方式に対応
- 既存のCookie認証も維持

---

### フロントエンド修正

#### 2. `frontend/appexit/lib/api-client.ts` - 全HTTPメソッドに`credentials: 'include'`追加

**変更内容**:
```typescript
// 修正前
const response = await fetch(url, {
  method: 'GET',
  headers,
  ...options,
});

// 修正後
const response = await fetch(url, {
  method: 'GET',
  headers,
  credentials: 'include', // Cookieを送信
  ...options,
});
```

**対象メソッド**: `get()`, `post()`, `put()`, `delete()`

**効果**:
- すべてのAPIリクエストでHttpOnly Cookieが自動送信される
- AuthorizationヘッダーとCookieの両方が送られる（バックエンドはどちらでも対応可能）

---

#### 3. `frontend/appexit/lib/auth-api.ts` - 認証関連APIに`credentials: 'include'`追加

**変更内容**:
```typescript
// loginWithBackend, registerWithBackend, createProfile関数に追加
credentials: 'include', // Cookieを送受信
```

**効果**:
- ログイン/登録時にバックエンドから返されるSet-CookieヘッダーでCookieが正しく設定される
- プロフィール作成APIでもCookieが送信される

---

#### 4. `frontend/appexit/components/pages/UserTypeSelectionPage.tsx` - 危険な手動Cookie解析を削除

**変更内容**:
```typescript
// 修正前: 危険な手動Cookie解析
const getCookie = (name: string): string | null => {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  // ...
}
const token = getCookie('auth_token')

// 修正後: Supabaseセッションから取得
import { supabase } from '@/lib/supabase'

const { data: { session } } = await supabase.auth.getSession()
const token = session?.access_token
```

**効果**:
- HttpOnly Cookieに頼らず、Supabaseセッションから確実にトークンを取得
- セキュリティリスクの削除
- より信頼性の高い実装

---

## 現在の認証フロー

### ログイン時
1. ユーザーがログインフォーム送信
2. `loginWithBackend()` → バックエンド `/api/auth/login`
   - `credentials: 'include'` でリクエスト
3. バックエンドが認証し、以下を返す:
   - JSON: `{ token, refresh_token, user, profile }`
   - Set-Cookie: `auth_token`, `refresh_token` (HttpOnly)
4. フロントエンドが:
   - Cookieを自動保存（ブラウザ処理）
   - `supabase.auth.setSession()` でSupabaseセッションを保存
   - AuthContextの状態を更新

### API呼び出し時
1. `apiClient.get/post/put/delete()` 使用
2. 内部で:
   - Supabaseセッションからトークンを取得
   - `Authorization: Bearer {token}` ヘッダーを設定
   - `credentials: 'include'` でHttpOnly Cookieも送信
3. バックエンドミドルウェアが:
   - まずAuthorizationヘッダーをチェック ✅
   - なければCookieをチェック ✅
   - どちらか一方があればOK

### ログアウト時
1. `signOut()` 呼び出し
2. バックエンド `/api/auth/logout` を呼び出し
   - `credentials: 'include'` でCookieを送信
   - バックエンドがCookieを削除
3. `supabase.auth.signOut()` でSupabaseセッションを削除
4. React Contextの状態をクリア

---

## 残存する設計上の考慮点

### トークンストレージの二重管理
現在、トークンは以下の2箇所に保存されています:

1. **HttpOnly Cookie** (バックエンドが管理)
   - XSS攻撃から保護
   - JavaScriptからアクセス不可

2. **Supabase LocalStorage** (フロントエンドが管理)
   - フロントエンドでトークンが必要な場合に使用
   - XSSリスクあり（ただしSupabaseのセキュリティ機能で緩和）

**推奨される今後の改善**:
- 可能であれば、**Cookieのみ**に統一する
- または、フロントエンドは常にCookieを使い、LocalStorageは完全に削除する
- これにより、トークン管理が一元化され、同期問題が解消される

### 現在の実装のメリット
- **柔軟性**: AuthorizationヘッダーとCookieの両方をサポート
- **互換性**: 既存のSupabase認証フローと共存可能
- **段階的移行**: 将来的にCookieのみに移行しやすい

---

## テスト推奨項目

以下のシナリオをテストして、修正が正しく機能することを確認してください:

### 1. ログインフロー
- [ ] ログイン成功後、Cookieが設定されている
- [ ] ログイン成功後、Supabaseセッションが存在する
- [ ] プロフィール未作成の場合、オンボーディングページにリダイレクト
- [ ] プロフィール作成済みの場合、ホームページにリダイレクト

### 2. 保護されたAPIコール
- [ ] `apiClient.get('/api/users')` が成功する
- [ ] `apiClient.post('/api/auth/profile', {...})` が成功する
- [ ] 認証なしでアクセスすると401エラーが返る

### 3. ページリロード
- [ ] ページリロード後もログイン状態が維持される
- [ ] 保護されたページにアクセスできる
- [ ] APIコールが引き続き成功する

### 4. ログアウトフロー
- [ ] ログアウト後、Cookieが削除される
- [ ] ログアウト後、Supabaseセッションが削除される
- [ ] ログアウト後、保護されたページにアクセスできない
- [ ] ログアウト後、APIコールが401エラーを返す

### 5. トークン期限切れ
- [ ] トークン期限切れ時、適切なエラーメッセージが表示される
- [ ] リフレッシュトークンで自動更新される（Supabase機能）

---

## まとめ

### 修正したファイル
1. `backend/internal/middleware/auth.go` - 認証ミドルウェア強化
2. `frontend/appexit/lib/api-client.ts` - credentials追加
3. `frontend/appexit/lib/auth-api.ts` - credentials追加
4. `frontend/appexit/components/pages/UserTypeSelectionPage.tsx` - 安全な実装に変更

### 主な改善点
- ✅ バックエンドがAuthorizationヘッダーとCookieの両方をサポート
- ✅ フロントエンドの全APIコールが`credentials: 'include'`を使用
- ✅ 危険な手動Cookie解析を削除
- ✅ 認証フローの一貫性を確保

### 現在の状態
認証システムは**根本的に修正**され、AuthorizationヘッダーとCookieの両方を使用した柔軟で安全な認証が実現されました。ページごとのアクセス制御とヘッダーでのログイン判定の不一致は解消されています。

**次のステップ**: 上記のテスト項目を実行して、すべての認証フローが正しく動作することを確認してください。
