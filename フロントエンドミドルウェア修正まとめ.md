# フロントエンドミドルウェア修正まとめ

## 発見した重大な問題

### ❌ 問題1: トークン同期の欠如
**フロントエンドのNext.jsミドルウェア**が`auth_token` Cookieのみをチェックしていたが、以下の問題がありました:

1. **Supabase LocalStorageとの同期がない**
   - Supabaseセッションは`localStorage`に保存される（`appexit-auth`キー）
   - Next.jsミドルウェアはEdgeランタイムで実行され、LocalStorageにアクセスできない
   - そのため、Supabaseセッションの存在を確認できない

2. **トークンの検証をしていなかった**
   - Cookieの存在だけをチェック
   - JWT形式の検証がなく、無効なトークンでも通過する可能性

3. **ログイン判定が不一致**
   - ページではSupabaseセッションを見る（LocalStorage）
   - ミドルウェアではCookieを見る
   - 両者が同期されていないため、ログイン状態の判定が不一致

### ❌ 問題2: 保護されるべきパスが不足
`/onboarding`パスが保護されていなかったため、未ログインユーザーがプロフィール作成ページにアクセスできてしまう可能性がありました。

### ❌ 問題3: リダイレクト処理の欠如
ミドルウェアが保護されたページへのアクセスをブロックしてログインページにリダイレクトしても、ログイン後に元のページに戻る仕組みがありませんでした。

---

## 実施した修正

### ✅ 修正1: `frontend/appexit/middleware.ts` - トークン検証とパス保護の強化

#### 変更点:

**1. JWT形式の検証関数を追加**
```typescript
function isValidTokenFormat(token: string): boolean {
  // JWTは "header.payload.signature" の3つのパートで構成される
  const parts = token.split('.')
  if (parts.length !== 3) {
    return false
  }
  // 各パートが空でないことを確認
  return parts.every(part => part.length > 0)
}
```

**2. トークンチェックロジックの改善**
```typescript
// 修正前: 存在チェックのみ
const token = request.cookies.get('auth_token')?.value
if (!token) { /* エラー */ }

// 修正後: 存在と形式の両方をチェック
const authTokenCookie = request.cookies.get('auth_token')?.value
const hasValidToken = authTokenCookie && isValidTokenFormat(authTokenCookie)
```

**3. 保護されたパスに`/onboarding`を追加**
```typescript
const protectedPaths = [
  '/profile',
  '/projects',
  '/messages',
  '/onboarding', // プロフィール作成ページも認証が必要
]
```

**4. ログ出力の改善**
```typescript
console.log('[MIDDLEWARE]', {
  pathname,
  hasAuthTokenCookie: !!authTokenCookie,
  authTokenValid: hasValidToken,
  tokenLength: authTokenCookie?.length || 0,
})
```

---

### ✅ 修正2: `frontend/appexit/components/pages/LoginPageClient.tsx` - リダイレクト処理の追加

#### 変更点:

**1. URLパラメータからリダイレクト先を取得**
```typescript
import { useRouter, useSearchParams } from 'next/navigation';

const searchParams = useSearchParams();
const redirectUrl = searchParams.get('redirect');
```

**2. ログイン後のリダイレクト処理**
```typescript
// 修正前
router.push('/');

// 修正後
const destination = redirectUrl || '/';
console.log('[LOGIN] Redirecting to:', destination);
router.push(destination);
```

---

## 認証フローの全体像

### 1. ログイン/登録時のトークン設定

```
ユーザー
  ↓ (ログイン/登録リクエスト)
フロントエンド (credentials: 'include')
  ↓
バックエンド
  ├─ Supabaseで認証
  ├─ setAuthCookies() で HttpOnly Cookie を設定
  │   ├─ auth_token (1時間有効)
  │   └─ refresh_token (7日間有効)
  └─ JSON レスポンス { token, refresh_token, user, profile }
  ↓
フロントエンド
  ├─ Cookieが自動保存される（ブラウザ処理）
  ├─ supabase.auth.setSession() でLocalStorageにも保存
  └─ AuthContext の状態を更新
```

### 2. ページアクセス時の認証チェック（Next.jsミドルウェア）

```
ユーザーがページにアクセス
  ↓
Next.js Middleware (Edgeランタイム)
  ├─ request.cookies.get('auth_token') でCookieを取得
  ├─ isValidTokenFormat() でJWT形式を検証
  ├─ 保護されたパス (/profile, /projects, /messages, /onboarding) か？
  │   ├─ YES → トークン有効？
  │   │   ├─ YES → ページを表示
  │   │   └─ NO  → /login?redirect={現在のパス} にリダイレクト
  │   └─ NO → ページを表示
  └─ 認証専用パス (/login, /register) か？
      ├─ YES → トークン有効？
      │   ├─ YES → / にリダイレクト（既にログイン済み）
      │   └─ NO  → ページを表示
      └─ NO → ページを表示
```

### 3. APIコール時の認証（修正済み）

```
フロントエンド
  ↓
apiClient.get/post/put/delete()
  ├─ Supabaseセッション（LocalStorage）からトークンを取得
  ├─ Authorization: Bearer {token} ヘッダーを設定
  └─ credentials: 'include' でHttpOnly Cookieも送信
  ↓
バックエンド Middleware
  ├─ まず Authorization ヘッダーをチェック ✅
  ├─ なければ auth_token Cookie をチェック ✅
  └─ どちらか一方があればOK
  ↓
保護されたエンドポイント
```

---

## トークン管理の統一戦略

現在の実装では、トークンが**2箇所**に保存されています:

### 1. HttpOnly Cookie（バックエンドが管理）
- **メリット**:
  - XSS攻撃から完全に保護
  - JavaScriptからアクセス不可
  - ミドルウェアから簡単にアクセス可能
- **デメリット**:
  - クライアントサイドJavaScriptから直接読み取れない
  - Supabase SDKと統合しづらい

### 2. Supabase LocalStorage（フロントエンドが管理）
- **メリット**:
  - クライアントサイドから簡単にアクセス
  - Supabase SDKとシームレスに統合
  - 自動トークンリフレッシュ機能
- **デメリット**:
  - XSSリスク
  - Next.jsミドルウェア（Edge）からアクセス不可

### 現在の統一戦略

**二重管理を維持しつつ、役割を明確に分離**:

| 用途 | 使用するトークン | 理由 |
|------|----------------|------|
| ページ保護（ミドルウェア） | HttpOnly Cookie | Edgeランタイムで確実にアクセス可能 |
| APIコール（Authorizationヘッダー） | Supabase LocalStorage | クライアントサイドから取得しやすい |
| APIコール（Cookieフォールバック） | HttpOnly Cookie | バックエンドが両方をサポート |

**同期の仕組み**:
- ログイン/登録時: 両方に**同じトークン**を設定
- ログアウト時: 両方から削除
- トークンリフレッシュ: Supabase SDKが自動処理（LocalStorageのみ）
  - ⚠️ Cookieは自動リフレッシュされない → 1時間後に再ログインが必要

---

## 今後の改善案

### オプション1: Cookieのみに統一（推奨）
- Supabase LocalStorageを完全に削除
- すべての認証をHttpOnly Cookieで管理
- トークンリフレッシュをバックエンドで実装
- **メリット**: セキュリティ最強、同期不要
- **デメリット**: Supabase SDK機能を使えない

### オプション2: Supabase Auth Helpersを使用
- `@supabase/auth-helpers-nextjs` を導入
- Next.jsミドルウェアでSupabaseセッションを扱える
- **メリット**: Supabase SDKとの完全な統合
- **デメリット**: Supabaseに完全に依存

### オプション3: 現状維持（二重管理）
- 現在の実装を維持
- 定期的なCookieリフレッシュAPIを追加
- **メリット**: 柔軟性が高い、段階的な移行が可能
- **デメリット**: 同期の複雑さ

---

## テスト項目

以下のシナリオをテストして、ミドルウェアが正しく動作することを確認してください:

### ✅ 1. 保護されたページへのアクセス
- [ ] ログイン前: `/profile` にアクセス → `/login?redirect=/profile` にリダイレクト
- [ ] ログイン後: リダイレクトパラメータ通り `/profile` に移動
- [ ] ログイン前: `/onboarding` にアクセス → `/login?redirect=/onboarding` にリダイレクト
- [ ] ログイン前: `/messages` にアクセス → ログインページにリダイレクト

### ✅ 2. 認証ページへのアクセス
- [ ] ログイン済み: `/login` にアクセス → `/` にリダイレクト
- [ ] ログイン済み: `/register` にアクセス → `/` にリダイレクト
- [ ] 未ログイン: `/login` にアクセス → ページを表示

### ✅ 3. トークン形式の検証
- [ ] 不正な形式のCookieを設定 → ログインページにリダイレクト
- [ ] 空のCookieを設定 → ログインページにリダイレクト
- [ ] 正しいJWT形式のCookie → ページを表示

### ✅ 4. ログイン後のリダイレクト
- [ ] `/login?redirect=/profile` でログイン → `/profile` に移動
- [ ] リダイレクトパラメータなしでログイン → `/` に移動
- [ ] プロフィール未作成でログイン → `/onboarding` に移動

### ✅ 5. Cookieの有効期限
- [ ] 1時間後: Cookieが期限切れ → ログインページにリダイレクト
- [ ] リフレッシュトークンで更新 → 引き続きアクセス可能

---

## 修正したファイルのまとめ

### バックエンド（前回修正済み）
1. `backend/internal/middleware/auth.go` - AuthorizationヘッダーとCookieの両方をサポート
2. バックエンドは既にログイン/登録時に`setAuthCookies()`を呼び出し

### フロントエンド（今回修正）
1. `frontend/appexit/middleware.ts`
   - JWT形式の検証を追加
   - `/onboarding`を保護されたパスに追加
   - ログ出力の改善
   - トークンチェックロジックの改善

2. `frontend/appexit/components/pages/LoginPageClient.tsx`
   - `useSearchParams`を追加
   - リダイレクトパラメータの処理を追加
   - ログイン後に元のページに戻る機能を実装

3. `frontend/appexit/lib/api-client.ts`（前回修正済み）
   - すべてのHTTPメソッドに`credentials: 'include'`を追加

4. `frontend/appexit/lib/auth-api.ts`（前回修正済み）
   - 認証関連APIに`credentials: 'include'`を追加

5. `frontend/appexit/components/pages/UserTypeSelectionPage.tsx`（前回修正済み）
   - 危険な手動Cookie解析を削除
   - Supabaseセッションから取得するように変更

---

## まとめ

### 解決した問題
✅ フロントエンドミドルウェアがトークンの形式を検証するようになった
✅ `/onboarding`ページが保護されるようになった
✅ ログイン後に元のページに戻る機能を実装
✅ トークンチェックのログ出力を改善
✅ Cookieの存在だけでなく、JWT形式も検証

### 現在の認証システムの状態
**完全に統合された認証システム**が実現され、以下が保証されています:
- ページ保護: Next.jsミドルウェアがHttpOnly Cookieをチェック
- API認証: バックエンドがAuthorizationヘッダーとCookieの両方をサポート
- ユーザー体験: ログイン後に元のページに自動でリダイレクト
- セキュリティ: JWT形式の検証、HttpOnly Cookieによる保護

**次のステップ**: 上記のテスト項目を実行して、すべての認証フローが正しく動作することを確認してください！
