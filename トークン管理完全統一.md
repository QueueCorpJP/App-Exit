# トークン管理完全統一 - 根本的な修正

## 🚨 発見した根本的な問題

### 投稿が無限待機する原因

**問題**: トークン管理が2つの異なる戦略で混在していた

1. **バックエンド**: HttpOnly Cookieを設定（`document.cookie`でJavaScriptから読めない）
2. **フロントエンドapiClient**: Cookieから読もうとする → **失敗** → Supabaseセッションにフォールバック
3. **フロントエンドミドルウェア**: Cookieの存在をチェック
4. **結果**: 一貫性のない認証状態、リクエストがハングする可能性

---

## ✅ 実装した統一戦略

### **唯一の真実の源: Supabase LocalStorage**

すべてのトークン管理をSupabase SDKとLocalStorageに統一しました。

#### なぜこの戦略？

| 側面 | 理由 |
|------|------|
| **一貫性** | フロントエンドとバックエンドで同じトークンを使用 |
| **シンプル** | 単一の保存場所、同期不要 |
| **機能性** | Supabase SDKによる自動トークンリフレッシュ |
| **開発体験** | JavaScriptから直接アクセス可能、デバッグが容易 |
| **互換性** | Supabaseエコシステムとの完全な統合 |

#### セキュリティに関する考慮

- **XSSリスク**: LocalStorageはXSS攻撃に対して脆弱
- **緩和策**:
  - Content Security Policy (CSP) の実装
  - Supabaseの短時間トークン（1時間有効）
  - トークンのスコープを最小限に（必要な権限のみ）
  - 本番環境ではHTTPS必須

---

## 📋 修正したファイル一覧

### バックエンド修正

#### 1. `backend/internal/handlers/auth.go`

**変更内容**:
- `setAuthCookies()` の呼び出しを削除
- トークンはJSON responseでのみ返す
- デバッグログを追加

```go
// 修正前
setAuthCookies(w, authResp.AccessToken, authResp.RefreshToken, &user, profilePtr)

// 修正後（削除）
fmt.Printf("[LOGIN] Returning tokens: access_token length=%d, refresh_token length=%d\n",
    len(authResp.AccessToken), len(authResp.RefreshToken))
```

#### 2. `backend/internal/middleware/auth.go`

**変更内容**:
- HttpOnly Cookieのチェックを削除
- **Authorizationヘッダーのみ**をチェック
- エラーメッセージを改善

```go
// 統一戦略: Authorizationヘッダーのみを使用
authHeader := r.Header.Get("Authorization")
if authHeader == "" {
    response.Error(w, http.StatusUnauthorized, "Missing authentication token")
    return
}

tokenString := authHeader[7:] // "Bearer " をスキップ
```

---

### フロントエンド修正

#### 3. `frontend/appexit/lib/api-client.ts`

**変更内容**:
- `getCookie()` メソッドを完全に削除
- Supabase sessionから**のみ**トークンを取得
- `credentials: 'include'` を全メソッドから削除

```typescript
// 統一戦略: Supabaseセッション（LocalStorage）を唯一の真実の源とする
private async getAuthToken(): Promise<string | null> {
  try {
    const { data } = await supabase.auth.getSession();
    const token = data.session?.access_token || null;

    if (token) {
      console.log('[API-CLIENT] Token found in Supabase session');
    }

    return token;
  } catch (error) {
    console.error('[API-CLIENT] Error getting token:', error);
    return null;
  }
}
```

#### 4. `frontend/appexit/middleware.ts`

**変更内容**:
- 認証チェックを完全に削除
- すべてのリクエストを通過させる
- コメントで戦略を明記

```typescript
/**
 * 統一戦略: ミドルウェアでの認証チェックは行わない
 * 理由:
 * - EdgeランタイムでLocalStorageにアクセスできない
 * - トークンはSupabase LocalStorageで管理される
 * - 実際の認証はAPIレベルで行われる
 */
export function middleware(request: NextRequest) {
  return NextResponse.next()
}
```

#### 5. `frontend/appexit/lib/auth-context.tsx`

**変更内容**:
- バックエンドのログアウトエンドポイント呼び出しを削除
- Supabase sessionのクリアのみ

```typescript
const signOut = async () => {
  // Supabaseからサインアウト（LocalStorageのセッションを削除）
  // 統一戦略: トークンはSupabase LocalStorageのみで管理
  await supabase.auth.signOut();

  // ステートをクリア
  setUser(null);
  setProfile(null);
  setToken(null);
};
```

#### 6. `frontend/appexit/components/pages/LoginPageClient.tsx`
#### 7. `frontend/appexit/components/pages/RegisterPageClient.tsx`
#### 8. `frontend/appexit/lib/auth-api.ts`

**変更内容**:
- すべての `credentials: 'include'` を削除
- トークンはJSON responseから取得してSupabase sessionに保存

---

## 🔄 統一された認証フロー

### 1. ログイン/登録フロー

```
┌─────────────────────────────────────────┐
│ ユーザーがログイン                         │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ フロントエンド                             │
│ POST /api/auth/login                    │
│ { email, password }                     │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ バックエンド                               │
│ 1. Supabaseで認証                        │
│ 2. JSON responseでトークンを返す          │
│    { token, refresh_token, user }       │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ フロントエンド                             │
│ 1. supabase.auth.setSession() を呼び出し │
│ 2. LocalStorageに自動保存                 │
│    (key: "appexit-auth")                │
│ 3. AuthContext の状態を更新              │
└─────────────────────────────────────────┘
```

### 2. APIコールフロー

```
┌─────────────────────────────────────────┐
│ フロントエンド                             │
│ apiClient.post('/api/posts', data)      │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ apiClient.getAuthToken()                │
│ ↓                                        │
│ supabase.auth.getSession()              │
│ ↓                                        │
│ LocalStorage: "appexit-auth" を読み取り  │
│ ↓                                        │
│ token = session.access_token            │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ fetch(url, {                            │
│   headers: {                            │
│     'Authorization': `Bearer ${token}`  │
│   }                                     │
│ })                                      │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ バックエンド Middleware                   │
│ 1. Authorization headerをチェック         │
│ 2. JWT トークンを検証                     │
│ 3. user_id をコンテキストに設定           │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ バックエンド Handler                      │
│ POST /api/posts を処理                   │
│ ↓                                        │
│ r.Context().Value("user_id")            │
│ ↓                                        │
│ 投稿を作成                                │
└─────────────────────────────────────────┘
```

### 3. ログアウトフロー

```
┌─────────────────────────────────────────┐
│ ユーザーがログアウト                        │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ フロントエンド                             │
│ 1. supabase.auth.signOut()              │
│    → LocalStorageから "appexit-auth" 削除│
│ 2. AuthContext の状態をクリア             │
│    (user, profile, token = null)        │
└─────────────────────────────────────────┘
```

---

## 🔐 トークン管理の全体像

### トークンの保存場所

| 場所 | 内容 | 管理者 | 用途 |
|------|------|--------|------|
| **LocalStorage** | `appexit-auth`: Supabaseセッション | Supabase SDK | 唯一の真実の源 |
| **React Context** | `token`, `user`, `profile` | AuthContext | UI表示用のキャッシュ |
| **メモリ** | API呼び出し時に取得 | apiClient | 一時的な使用 |

### トークンのライフサイクル

```
[ログイン]
   ↓
[Supabase SDK → LocalStorage保存]
   ↓
[AuthContext → メモリにキャッシュ]
   ↓
[API呼び出し時]
   ↓
[supabase.auth.getSession() → トークン取得]
   ↓
[Authorization: Bearer {token}]
   ↓
[バックエンド検証]
   ↓
[トークン期限切れ？]
   ├─ YES → Supabase SDKが自動リフレッシュ
   └─ NO  → そのまま使用
   ↓
[ログアウト]
   ↓
[LocalStorageからクリア]
```

---

## 🎯 フロントエンドとバックエンドの互換性

### 互換性マトリクス

| フロントエンド | バックエンド | 互換性 | 理由 |
|--------------|------------|--------|------|
| Authorization header | Authorizationチェック | ✅ 完全互換 | 直接マッチ |
| LocalStorage → header | Authorizationチェック | ✅ 完全互換 | 同じトークンを使用 |
| Supabaseセッション | Supabase JWT検証 | ✅ 完全互換 | 同じシークレットで検証 |

### トークン形式の互換性

```
フロントエンド:
  Supabase JWT (HS256)
  claims: { sub, email, role, exp, ... }

バックエンド:
  SupabaseJWTClaims struct
  検証: HS256, SUPABASE_JWT_SECRET

→ 100% 互換性あり
```

---

## 🧪 テスト項目

以下の順序で必ずテストしてください:

### 1. ログインフロー
- [ ] メール・パスワードでログイン
- [ ] ブラウザのDevTools → Application → Local Storage → `appexit-auth` が存在
- [ ] `access_token`が保存されていることを確認
- [ ] ログイン後、ホームページまたはオンボーディングにリダイレクト

### 2. API呼び出し（投稿作成）
- [ ] `/projects/new` にアクセス
- [ ] フォームに入力
- [ ] 「アプリを投稿」ボタンをクリック
- [ ] **投稿が成功し、無限待機しない**
- [ ] `/apps` ページにリダイレクト

### 3. トークンの検証
- [ ] ブラウザのDevTools → Network → リクエストを確認
- [ ] `Authorization: Bearer eyJhbG...` ヘッダーが設定されている
- [ ] バックエンドログで `[AUTH] Token from Authorization header` が表示される
- [ ] バックエンドログで `[AUTH] Supabase token verified for user: ...` が表示される

### 4. ページリロード
- [ ] ページをリロード
- [ ] ログイン状態が維持される
- [ ] LocalStorageの`appexit-auth`が残っている
- [ ] API呼び出しが引き続き成功

### 5. ログアウト
- [ ] ログアウトボタンをクリック
- [ ] LocalStorageから`appexit-auth`が削除される
- [ ] AuthContextの状態がクリアされる
- [ ] ログインページにリダイレクト
- [ ] 保護されたAPIにアクセスすると401エラー

### 6. トークン期限切れ
- [ ] 1時間待つ（またはトークンを手動で期限切れにする）
- [ ] Supabase SDKが自動的にトークンをリフレッシュ
- [ ] APIコールが引き続き成功

---

## 📊 トラブルシューティング

### 問題: 投稿が無限に待機する

**チェック項目**:
1. ブラウザのDevTools → Console → エラーメッセージを確認
2. Network tab → リクエストの詳細を確認
   - Authorization headerが設定されているか？
   - ステータスコードは？（401, 500, など）
3. LocalStorage → `appexit-auth` が存在するか？
4. バックエンドログを確認
   - `[AUTH] Token from Authorization header` が表示されるか？
   - `[AUTH] ERROR: ...` があるか？

**解決策**:
- LocalStorageを手動でクリア: `localStorage.clear()`
- 再ログイン
- バックエンドを再起動
- フロントエンドを再起動

### 問題: 401 Unauthorized エラー

**原因**:
- トークンが存在しない
- トークンの形式が不正
- トークンが期限切れ
- バックエンドのJWT secretが間違っている

**解決策**:
1. ログアウト → 再ログイン
2. `.env`ファイルの`SUPABASE_JWT_SECRET`を確認
3. Supabase Dashboardで正しいJWT secretを取得

### 問題: トークンが保存されない

**チェック項目**:
- ログイン後、`supabase.auth.setSession()`が呼ばれているか？
- LocalStorageが有効か？（プライベートモードではない）
- ブラウザの設定でLocalStorageがブロックされていないか？

---

## 🔒 セキュリティ考慮事項

### 現在の実装

| セキュリティ機能 | 状態 | 詳細 |
|----------------|------|------|
| HTTPS | ⚠️ 本番で必須 | 開発環境ではHTTP |
| トークン有効期限 | ✅ 実装済み | 1時間（Supabaseデフォルト） |
| 自動リフレッシュ | ✅ 実装済み | Supabase SDKが自動処理 |
| XSS保護 | ⚠️ 要改善 | CSPの実装を推奨 |
| CORS | ✅ 実装済み | バックエンドで設定 |

### 推奨される追加対策

1. **Content Security Policy (CSP)**
```html
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'">
```

2. **本番環境でのHTTPS強制**
```typescript
if (process.env.NODE_ENV === 'production' && !window.location.protocol.includes('https')) {
  window.location.protocol = 'https:';
}
```

3. **トークンのスコープ制限**
- Supabase RLSポリシーで権限を最小化
- 必要な権限のみを付与

---

## 📝 まとめ

### 変更の要点

1. **削除したもの**:
   - HttpOnly Cookieの設定・読み取り
   - Cookieベースの認証チェック
   - Next.jsミドルウェアでの認証ガード

2. **統一したもの**:
   - **Supabase LocalStorage**を唯一の真実の源に
   - **Authorizationヘッダー**のみでトークンを送信
   - **バックエンドAPIミドルウェア**で認証を一元管理

3. **改善したもの**:
   - 一貫性のあるトークンフロー
   - デバッグしやすいログ出力
   - 明確なコメントとドキュメント

### なぜこの戦略が優れているか

| 側面 | 改善点 |
|------|--------|
| **シンプル** | 単一の保存場所、複雑な同期不要 |
| **一貫性** | フロントエンドとバックエンドで同じトークン |
| **機能性** | Supabase SDKの自動リフレッシュ |
| **開発体験** | JavaScriptから直接アクセス可能 |
| **デバッグ** | LocalStorageで簡単に確認できる |
| **パフォーマンス** | Cookieの解析不要 |

### 次のステップ

1. ✅ すべてのテスト項目を実行
2. ✅ バックエンドとフロントエンドを再起動
3. ✅ 投稿作成が正常に動作することを確認
4. ✅ 本番環境デプロイ前にCSPを実装
5. ✅ HTTPSを強制

**これで認証システムは完全に統一され、投稿作成が正常に動作するはずです！** 🎉
